<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<canvas id="particle" width="800" height="500"></canvas>

</body>
<script>
    const [minX, minY, maxX, maxY] = [0, 0, 700, 480];

    let ctx = null;
    let particles = [];
    let requestA = [];//requestAnimation 的对象

    function rand(min, max) {
        //~~运算符是取整 按位取整
        return (Math.random() * (max - min)) + min;
    }

    function init() {
        ctx = document.getElementById('particle').getContext('2d');
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, 800, 500);
        /**********
         * 1.生成随机点
         * 2.随机点直接随机连续   连过的线去重
         * 3.随机点开始动画
         */
        particles = generateRandomPoint();

        startAnimate();
        // console.log('particles',particles);
    }

    function startAnimate() {

        ctx.clearRect(0, 0, 800, 500);

        //给个目标点 让 每一个粒子朝目标点移动
        //位移 点 和线
        for (let i = 0; i < particles.length; i++) {
            let particle = particles[i];
            // console.log('222');
            ctx.clearRect(0, 0, 800, 500);
            particle.moveAnimation();
        }

    }

    function getDirection(value, num) {
        //    反方向位移还是正方向位移
        return value + (parseInt(rand(0, 2)) === 0 ? (-num) : num);
    }

    function ligature() {
        // console.log('particles',particles);
        for (let i = 0; i < particles.length - 1; i++) {
            let particle = particles[i];
            particle.lineToB(particles[i + 1]);
            particle.draw();
        }

        particles[particles.length - 1].lineToB(particles[0]);

    }

    function isSameForArr(particle) {
        let isSame = false;
        for (let j = 0; j < particles.length; j++) {
            let particle1 = particles[j];
            if (particle1.x === particle.x && particle1.y === particle.y) {
                isSame = true;
                break;
            }
        }
        return isSame;
    }

    function generateRandomPoint() {

        let particles = [];
        for (let i = 0; i < 20; i++) {
            let particle = new Particle();
            //去重
            if (!isSameForArr(particle)) {
                particles.push(particle);
            }
        }
        return particles;

    }

    class Particle {
        constructor(point) {
            if(point&& point.x && point.y){
                this.x = point.x;
                this.y = point.y;
            }else{
                this.x = rand(minX, maxX);
                this.y = rand(minY, maxY);
            }

            this.color = 'red';
            this.radius = 3;
            this.pre = 20;//移动片段
            this.targetPoint = {
                x: this.x,
                y: this.y,
            };
            this.interval = null;
            //透明度
            this.opacity = 1;
            //判断这个点是否移动啦
            this.draw();
            this.buildTargetPoint();
            this.speed = this.getSpeed();//向目标点移动的速度

        }

        buildTargetPoint() {

            this.targetPoint = {
                x: getDirection(this.x, 80),
                y: getDirection(this.y, 100)
            };

            if ((this.targetPoint.x <= 0 || this.targetPoint.x >= 799) || (this.targetPoint.y <= 0 || this.targetPoint.y >= 499)) {
                this.buildTargetPoint();
            }
        }

        isToTarget() {
            return parseInt(this.x) === parseInt(this.targetPoint.x) && parseInt(this.y) === parseInt(this.targetPoint.y);
        }

        getSpeed() {
            return {
                x: (this.targetPoint.x - this.x) / this.pre,
                y: (this.targetPoint.y - this.y) / this.pre
            }
        }

        moveAnimation() {
            // console.log('2');
            ctx.clearRect(0, 0, 800, 500);

            ligature();
            let that = this;

            this.x = this.x + this.speed.x;
            this.y = this.y + this.speed.y;

            //如果到达了目标点 就重新生成目标点
            if (this.isToTarget()) {
                // console.log('1');
                ctx.clearRect(0, 0, 800, 500);
                this.buildTargetPoint();
                this.speed = this.getSpeed();
                this.moveAnimation();

            } else {

                requestA.push(requestAnimationFrame(function () {
                    that.moveAnimation();

                }))

            }
        }

        lineToB(particle) {
            ctx.beginPath();
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.2;
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(particle.x, particle.y);
            ctx.stroke();
            ctx.save();
        }

        draw( point) {
            if (point && point.x && point.y) {
                this.x = point.x;
                this.y = point.y;
            }
            ctx.beginPath();
            ctx.strokeStyle = this.color;
            ctx.globalAlpha = 0.8;
            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.restore();
        }

        setRadius(radius){
            this.radius = radius;
        }
    }

    init();

    document.getElementById('particle').addEventListener('mousedown', function (e) {
        e = e || window.event;
        let moveX = e.pageX;
        let moveY = e.pageY;
        //获取附近最近的两个点
        let ePoint = {
            x:moveX,
            y:moveY
        };

        sortForPoint(ePoint);

        let p = new Particle(ePoint);
        p.setRadius(8);
        particles.push(p);
        particles.shift();


        if(requestA){
            for (let i = 0; i < requestA.length; i++) {
                let pElement = requestA[i];
                cancelAnimationFrame(pElement);
            }
            requestA = [];
            startAnimate();
        }
        console.log('ePoint',ePoint);

    });

    function sortForPoint(point){

        for (let i = 0; i < particles.length; i++) {
            let particle = particles[i];
            particle.offsetX = Math.abs(particle.x - point.x);
            particle.offsetY = Math.abs(particle.y - point.y);
            particle.offset = particle.offsetX + particle.offsetY;
        }


        particles.sort(function (item, item1) {
            return item1.offset - item.offset;
        });
    }
    // function getNearPoint(point) {
    //     let particles_map = Object.assign(particles);
    //
    //     for (let i = 0; i < particles_map.length; i++) {
    //         let particle = particles_map[i];
    //         particle.offsetX = Math.abs(particle.x - point.x);
    //         particle.offsetY = Math.abs(particle.y - point.y);
    //         particle.offset = particle.offsetX + particle.offsetY;
    //     }
    //
    //
    //     particles_map.sort(function (item, item1) {
    //         return item.offset - item1.offset;
    //     });
    //
    //
    //     return [particles_map[0], particles_map[1]];
    // }

</script>
</html>
